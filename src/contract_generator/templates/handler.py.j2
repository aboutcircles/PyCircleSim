{# handler.py.j2 #}
import random
from datetime import datetime
import logging
from typing import Optional, Dict, Any, Tuple

from ape import chain
from eth_pydantic_types import HexBytes
from src.framework.agents import BaseAgent
from src.protocols.{{ contract_name.lower() }} import {{ contract_name }}Client

{% for func in functions if not func.is_view %}
class {{ func.name|camel_case }}Handler:
    """Encapsulates the logic to execute a {{ func.name }} action."""

    def __init__(
        self,
        client: {{ contract_name }}Client,
        chain,
        logger: logging.Logger,
        on_{{ func.name|lower }}_performed=None
    ):
        self.client = client
        self.chain = chain
        self.logger = logger
        self.on_{{ func.name|lower }}_performed = on_{{ func.name|lower }}_performed

    def _get_params(self, agent: BaseAgent) -> Dict[str, Any]:
        """Get internally computed parameters if needed"""
    
        return {}

    def execute(self, agent: BaseAgent, params: Optional[Dict[str, Any]] = None) -> bool:
        try:
            # Get internal params if no external params provided
            execution_params = params if params else self._get_params(agent)
            if not execution_params:
                return False
            
            success = self.client.{{ func.name }}(
                sender=execution_params.get('sender'),
                {% for inp in func.inputs %}
                {% set param_name = inp.name if inp.name else "param" + loop.index0|string %}
                {{ param_name }}=execution_params.get('{{ param_name }}'),
                {% endfor %}
            )

            if success and self.on_{{ func.name|lower }}_performed:
                self.on_{{ func.name|lower }}_performed(
                    sender=execution_params.get('sender'),
                    {% for inp in func.inputs %}
                    {% set param_name = inp.name if inp.name else "param" + loop.index0|string %}
                    {{ param_name }}=execution_params.get('{{ param_name }}'),
                    {% endfor %}
                    block=self.chain.blocks.head.number,
                    timestamp=datetime.fromtimestamp(self.chain.blocks.head.timestamp)
                )

            return success

        except Exception as e:
            self.logger.error(f"{{ func.name }} action failed for agent {agent.agent_id}: {e}", exc_info=True)
            return False
{% endfor %}